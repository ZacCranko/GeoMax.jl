n = 15
s = JManOpt.PositiveDefinite(n)

# Just test that rand returns a point on the manifold and two
# different matrices generated by rand aren't too close together
x = rand(s)
@test size(x) == (n, n)

# Check symmetry
@test isapprox(x, JManOpt.multisym(x))

l = eigvals(x)
@test all(l .> [0])

x = Hermitian(rand(s))
u = JManOpt.randvec(s, x)
e = expm(x\u)

@test isapprox(JManOpt.multiprod(x, e), exp(s, x, u))
u = u * 1e-6
@test isapprox(exp(s, x, u), x + u)

# Just test that randvec returns an element of the tangent space
# with norm 1 and that two randvecs are different.
x = rand(s)
u = JManOpt.randvec(s, x)
v = JManOpt.randvec(s, x)
@test isapprox(JManOpt.multisym(u), u)
@test isapprox(1, norm(s, x, u))
@test vecnorm(u - v) > 1e-3

#--------------------------------
# Multidim Test
#--------------------------------
n = 10
k = 3
s = JManOpt.PositiveDefinite(n, k)

@test isapprox(JManOpt.dim(s), 0.5 * s.k * s.n * (s.n+1))

@test isapprox(JManOpt.typicaldist(s), sqrt(JManOpt.dim(s)))

x = rand(s)
y = rand(s)

d = JManOpt.solve(x,y)
d = logm.(d)
@test isapprox(JManOpt.dist(s, x, y), vecnorm(d))

x = rand(s)
a, b = randn(2, s.k, s.n, s.n)
@test isapprox(vecdot(a, b), JManOpt.inner(s, x, JManOpt.multiprod(x, a), JManOpt.multiprod(x, b)))

x = rand(s)
a = randn(s.k, s.n, s.n)
@test isapprox(JManOpt.proj(s, x, a), JManOpt.multisym(a))

x = rand()
u = randn(s.k, s.n, s.n)
@test isapprox(JManOpt.egrad2rgrad(s, x, u),JManOpt.multiprod(JManOpt.multiprod(x, JManOpt.multisym(u)), x))

x = rand(s)
egrad, ehess = randn(2, s.k, s.n, s.n)
u = JManOpt.randvec(s, x)

Hess = (multiprod(multiprod(x, multisym(ehess)), x) +
        2*multisym(multiprod(multiprod(u, multisym(egrad)), x)))

# Correction factor for the non-constant metric
Hess = Hess - multisym(multiprod(multiprod(u, multisym(egrad)), x))
@test isapprox(Hess, man.ehess2rhess(x, egrad, ehess,
                                                     u))
x = rand(s)
a = randn(s.k, s.n, s.n)
@test isapprox(vecnorm(a), JManOpt.norm(s, x, multiprod(x, a)))

# Just test that rand returns a point on the manifold and two
# different matrices generated by rand aren't too close together
x = rand(s)

@test size(x) == (s.k, s.n, s.n)

# Check symmetry
@test isapprox(x, multisym(x))

# TODO This
# Check positivity of eigenvalues
#l = la.eigvalsh(x)
#assert (l > [[0]]).all()

# Just test that randvec returns an element of the tangent space
# with norm 1 and that two randvecs are different.
x = rand(s)
u = JManOpt.randvec(s, x)
v = JManOpt.randvec(s, x)
@test isapprox(multisym(u), u)
@test isapprox(1, norm(s, x, u))
assert vecnorm(u - v) > 1e-3

x = rand(s)
y = rand(s)
u = JManOpt.randvec(s, x)
@test isapprox(JManOpt.transp(s, x, y, u), u)

# Test against manopt implementation, test that for small vectors
# exp(x, u) = x + u.
x = rand(s)
u = JManOpt.randvec(s, x)
e = zeros(s.k, s.n, s.n)

#TODO this
# for i in range(s.k):
#     e[i] = sp.linalg.expm(la.solve(x[i], u[i]))
# @test isapprox(multiprod(x, e), exp(x, u))
u = u * 1e-6
@test isapprox(exp(s, x, u), x + u)

# Check that result is on manifold and for small vectors
# retr(x, u) = x + u.
u = JManOpt.randvec(s, x)
x = rand(s)
y = JManOpt.retr(s, x, u)

@test size(y) == (s.k, s.n, s.n)
# Check symmetry
@test isapprox(y, multisym(y))

l = eig(y)
@test all((l .> 0))

u = u * 1e-6
@test isapprox(JManOpt.retr(s, x, u), x + u)

x = rand(s)
y = rand(s)
u = log(s, x, y)
@test isapprox(exp(s, x, u), y)

x = rand(s)
u = JManOpt.randvec(s, x)
y = exp(s, x, u)
@test isapprox(log(s, x, y), u)
