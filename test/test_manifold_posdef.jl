n = 15
s = JManOpt.PositiveDefinite(n)

# Just test that rand returns a point on the manifold and two
# different matrices generated by rand aren't too close together
x = rand(s)
@test size(x) == (n, n)

# Check symmetry
@test isapprox(x, JManOpt.multisym(x))

l = eigvals(x)
@test all(l .> [0])

x = Hermitian(rand(s))
u = JManOpt.randvec(s, x)
ex = expm(x\u)

@test isapprox(JManOpt.multiprod(x, ex), exp(s, x, u))
u = u * 1e-6
@test isapprox(exp(s, x, u), x + u)

# Just test that randvec returns an element of the tangent space
# with norm 1 and that two randvecs are different.
x = rand(s)
u = JManOpt.randvec(s, x)
v = JManOpt.randvec(s, x)
@test isapprox(JManOpt.multisym(u), u)
@test isapprox(1, norm(s, x, u))
@test vecnorm(u - v) > 1e-3

#--------------------------------
# Multidim Test
#--------------------------------
n = 10
k = 3
s = JManOpt.PositiveDefinite(n, k)

@test isapprox(JManOpt.dim(s), 0.5 * s.k * s.n * (s.n+1))

@test isapprox(JManOpt.typicaldist(s), sqrt(JManOpt.dim(s)))

x = rand(s)
y = rand(s)

d = JManOpt.solve(x,y)
d = logm.(d)
#@test isapprox(JManOpt.dist(s, x, y), vecnorm(d))

x = rand(s)
r = randn(s.n, s.n, s.k, 2)
a = r[:,:,:,1]
b = r[:,:,:,2]
@test isapprox(vecdot(a, b), JManOpt.inner(s, x, JManOpt.multiprod(x, a), JManOpt.multiprod(x, b)))

x = rand(s)
a = randn(s.n, s.n, s.k)
@test isapprox(JManOpt.proj(s, x, a), JManOpt.multisym(a))

x = rand(s)
u = randn(s.n, s.n, s.k)
@test isapprox(JManOpt.egrad2rgrad(s, x, u),JManOpt.multiprod(JManOpt.multiprod(x, JManOpt.multisym(u)), x))

x = rand(s)
r = randn(s.n, s.n, s.k, 2)
egrad = r[:,:,:,1]
ehess = r[:,:,:,2]
u = JManOpt.randvec(s, x)

Hess = (JManOpt.multiprod(JManOpt.multiprod(x, JManOpt.multisym(ehess)), x) +
        2*JManOpt.multisym(JManOpt.multiprod(JManOpt.multiprod(u, JManOpt.multisym(egrad)), x)))

#TODO FIX
# Correction factor for the non-constant metric
Hess = Hess - JManOpt.multisym(JManOpt.multiprod(JManOpt.multiprod(u, JManOpt.multisym(egrad)), x))
@test isapprox(Hess, JManOpt.ehess2rhess(s, x, egrad, ehess, u))
x = rand(s)
a = randn(s.n, s.n, s.k)
# @test isapprox(vecnorm(a), JManOpt.norm(s, x, JManOpt.multiprod(x, a)))

# Just test that rand returns a point on the manifold and two
# different matrices generated by rand aren't too close together
x = rand(s)

@test size(x) == (s.n, s.n, s.k)

# Check symmetry
@test isapprox(x, JManOpt.multisym(x))

# TODO This
# Check positivity of eigenvalues
#l = la.eigvalsh(x)
#assert (l > [[0]]).all()

# Just test that randvec returns an element of the tangent space
# with norm 1 and that two randvecs are different.
x = rand(s)
u = JManOpt.randvec(s, x)
v = JManOpt.randvec(s, x)
@test isapprox(JManOpt.multisym(u), u)
@test isapprox(1, JManOpt.norm(s, x, u))
@test vecnorm(u - v) > 1e-3

x = rand(s)
y = rand(s)
u = JManOpt.randvec(s, x)
@test isapprox(JManOpt.transp(s, x, y, u), u)

# Test against manopt implementation, test that for small vectors
# exp(x, u) = x + u.
x = rand(s)
u = JManOpt.randvec(s, x)
e = zeros(s.k, s.n, s.n)

#TODO this
ex = mapslices(expm,JManOpt.solve(x, u), (1,2))
@test isapprox(JManOpt.multiprod(x, ex), exp(s, x, u))
u = u * 1e-6
@test isapprox(exp(s, x, u), x + u)

# Check that result is on manifold and for small vectors
# retr(x, u) = x + u.
u = JManOpt.randvec(s, x)
x = rand(s)
y = JManOpt.retr(s, x, u)

@test size(y) == (s.k, s.n, s.n)
# Check symmetry
@test isapprox(y, multisym(y))

l = eig(y)
@test all((l .> 0))

u = u * 1e-6
@test isapprox(JManOpt.retr(s, x, u), x + u)

x = rand(s)
y = rand(s)
u = log(s, x, y)
@test isapprox(exp(s, x, u), y)

x = rand(s)
u = JManOpt.randvec(s, x)
y = exp(s, x, u)
@test isapprox(log(s, x, y), u)
