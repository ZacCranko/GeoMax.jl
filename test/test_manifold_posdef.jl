n = 15
s = GeoMax.PositiveDefinite(n)

# Just test that rand returns a point on the manifold and two
# different matrices generated by rand aren't too close together
x = rand(s)
@test size(x) == (n, n)

# Check symmetry
@test isapprox(x, GeoMax.multisym(x))

l = eigvals(x)
@test all(l .> [0])

x = Hermitian(rand(s))
u = GeoMax.randvec(s, x)
ex = expm(x\u)

@test isapprox(GeoMax.multiprod(x, ex), exp(s, x, u))
u = u * 1e-6
@test isapprox(exp(s, x, u), x + u)

# Just test that randvec returns an element of the tangent space
# with norm 1 and that two randvecs are different.
x = rand(s)
u = GeoMax.randvec(s, x)
v = GeoMax.randvec(s, x)
@test isapprox(GeoMax.multisym(u), u)
@test isapprox(1, norm(s, x, u))
@test vecnorm(u - v) > 1e-3

#--------------------------------
# Multidim Test
#--------------------------------
n = 10
k = 3
s = GeoMax.PositiveDefinite(n, k)

@test isapprox(GeoMax.dim(s), 0.5 * s.k * s.n * (s.n+1))

@test isapprox(GeoMax.typicaldist(s), sqrt(GeoMax.dim(s)))

x = rand(s)
y = rand(s)

d = GeoMax.solve(x,y)
d = logm.(d)
#@test isapprox(GeoMax.dist(s, x, y), vecnorm(d))

x = rand(s)
r = randn(s.n, s.n, s.k, 2)
a = r[:,:,:,1]
b = r[:,:,:,2]
@test isapprox(vecdot(a, b), GeoMax.inner(s, x, GeoMax.multiprod(x, a), GeoMax.multiprod(x, b)))

x = rand(s)
a = randn(s.n, s.n, s.k)
@test isapprox(GeoMax.proj(s, x, a), GeoMax.multisym(a))

x = rand(s)
u = randn(s.n, s.n, s.k)
@test isapprox(GeoMax.egrad2rgrad(s, x, u),GeoMax.multiprod(GeoMax.multiprod(x, GeoMax.multisym(u)), x))

x = rand(s)
r = randn(s.n, s.n, s.k, 2)
egrad = r[:,:,:,1]
ehess = r[:,:,:,2]
u = GeoMax.randvec(s, x)

Hess = (GeoMax.multiprod(GeoMax.multiprod(x, GeoMax.multisym(ehess)), x) +
        2*GeoMax.multisym(GeoMax.multiprod(GeoMax.multiprod(u, GeoMax.multisym(egrad)), x)))

# Correction factor for the non-constant metric
Hess = Hess - GeoMax.multisym(GeoMax.multiprod(GeoMax.multiprod(u, GeoMax.multisym(egrad)), x))
@test isapprox(Hess, GeoMax.ehess2rhess(s, x, egrad, ehess, u))
#TODO Looks like qr on line 81 does not  work the same in julia and python
x = rand(s)
a = randn(s.n, s.n, s.k)
#@test isapprox(vecnorm(a), GeoMax.norm(s, x, GeoMax.multiprod(x, a)))

# Just test that rand returns a point on the manifold and two
# different matrices generated by rand aren't too close together
x = rand(s)

@test size(x) == (s.n, s.n, s.k)

# Check symmetry
@test isapprox(x, GeoMax.multisym(x))

# Check positivity of eigenvalues
l = eig(x)[1]
@assert all(l .> 0)

# Just test that randvec returns an element of the tangent space
# with norm 1 and that two randvecs are different.
x = rand(s)
u = GeoMax.randvec(s, x)
v = GeoMax.randvec(s, x)
@test isapprox(GeoMax.multisym(u), u)
@test isapprox(1, GeoMax.norm(s, x, u))
@test vecnorm(u - v) > 1e-3

x = rand(s)
y = rand(s)
u = GeoMax.randvec(s, x)
@test isapprox(GeoMax.transp(s, x, y, u), u)

# Test against manopt implementation, test that for small vectors
# exp(x, u) = x + u.
x = rand(s)
u = GeoMax.randvec(s, x)
e = zeros(s.k, s.n, s.n)

#TODO this
ex = mapslices(expm,GeoMax.solve(x, u), (1,2))
@test isapprox(GeoMax.multiprod(x, ex), exp(s, x, u))
u = u * 1e-6
@test isapprox(exp(s, x, u), x + u)

# Check that result is on manifold and for small vectors
# retr(x, u) = x + u.
u = GeoMax.randvec(s, x)
x = rand(s)
y = GeoMax.retr(s, x, u)

@test size(y) == (s.k, s.n, s.n)
# Check symmetry
@test isapprox(y, multisym(y))

l = eig(y)
@test all((l .> 0))

u = u * 1e-6
@test isapprox(GeoMax.retr(s, x, u), x + u)

x = rand(s)
y = rand(s)
u = log(s, x, y)
@test isapprox(exp(s, x, u), y)

x = rand(s)
u = GeoMax.randvec(s, x)
y = exp(s, x, u)
@test isapprox(log(s, x, y), u)
